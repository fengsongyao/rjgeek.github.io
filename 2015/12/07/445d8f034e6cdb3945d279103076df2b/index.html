<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>【系统架构】memcached全面剖析--5. memcached的应用和兼容程序 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="# 


发表日：2008/7/30
作者：长野雅广(Masahiro Nagano)
原文链接：http://gihyo.jp/dev/feature/01/memcached/0005">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="【系统架构】memcached全面剖析--5. memcached的应用和兼容程序"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-07T17:51:14.000Z"><a href="/2015/12/07/445d8f034e6cdb3945d279103076df2b/">2015-12-07</a></time>
      
      
  
    <h1 class="title">【系统架构】memcached全面剖析--5. memcached的应用和兼容程序</h1>
  

    </header>
    <div class="entry">
      
        <header>

<p># </p>
<p></p></header><section><p></p>
<ul>
<li>发表日：2008/7/30</li>
<li>作者：长野雅广(Masahiro Nagano)</li>
<li>原文链接：<a href="http://gihyo.jp/dev/feature/01/memcached/0005" target="_blank" rel="external">http://gihyo.jp/dev/feature/01/memcached/0005</a><a id="more"></a></li>
</ul>
<p>前几次的文章在这里：</p>
<ul>
<li>第1次：</li>
<li>第2次：<a href="http://tech.idv2.com/2008/07/11/memcached-002/" target="_blank" rel="external">http://tech.idv2.com/2008/07/11/memcached-002/</a></li>
<li>第3次：<a href="http://tech.idv2.com/2008/07/16/memcached-003/" target="_blank" rel="external">http://tech.idv2.com/2008/07/16/memcached-003/</a></li>
<li>第4次：<a href="http://tech.idv2.com/2008/07/24/memcached-004/" target="_blank" rel="external">http://tech.idv2.com/2008/07/24/memcached-004/</a></li>
</ul>
<p>我是Mixi的长野。memcached的连载终于要结束了。 到<a href="http://tech.idv2.com/2008/07/24/memcached-004/" target="_blank" rel="external">上次</a>为止， 我们介绍了与memcached直接相关的话题，本次介绍一些mixi的案例和 实际应用上的话题，并介绍一些与memcached兼容的程序。</p>
<h1 id="mixi案例研究"><a href="#mixi案例研究" class="headerlink" title="mixi案例研究"></a>mixi案例研究</h1><p>mixi在提供服务的初期阶段就使用了memcached。&nbsp;<br>随着网站访问量的急剧增加，单纯为数据库添加slave已无法满足需要，因此引入了memcached。 此外，我们也从增加可扩展性的方面进行了验证，证明了memcached的速度和稳定性都能满足需要。 现在，memcached已成为mixi服务中非常重要的组成部分。</p>
<p><img src="http://helloword.1kapp.com/wp-content/uploads/2015/12/wpid-b9b063ef707aab527e9d3324b1588fa6_76c12581-7008-487a-9aa0-cc078fd62c6d.png" alt="memcached-0005-01.png"></p>
<p>图1 现在的系统组件</p>
<h2 id="服务器配置和数量"><a href="#服务器配置和数量" class="headerlink" title="服务器配置和数量"></a>服务器配置和数量</h2><p>mixi使用了许许多多服务器，如数据库服务器、应用服务器、图片服务器、&nbsp;<br>反向代理服务器等。单单memcached就有将近200台服务器在运行。 memcached服务器的典型配置如下：</p>
<ul>
<li>CPU：Intel Pentium 4 2.8GHz</li>
<li>内存：4GB</li>
<li>硬盘：146GB SCSI</li>
<li>操作系统：Linux（x86_64）</li>
</ul>
<p>这些服务器以前曾用于数据库服务器等。随着CPU性能提升、内存价格下降， 我们积极地将数据库服务器、应用服务器等换成了性能更强大、内存更多的服务器。 这样，可以抑制mixi整体使用的服务器数量的急剧增加，降低管理成本。 由于memcached服务器几乎不占用CPU，就将换下来的服务器用作memcached服务器了。</p>
<h2 id="memcached进程"><a href="#memcached进程" class="headerlink" title="memcached进程"></a>memcached进程</h2><p>每台memcached服务器仅启动一个memcached进程。分配给memcached的内存为3GB， 启动参数如下：</p>
<pre><code>/usr/bin/memcached -p 11211 -u nobody -m 3000 -c 30720
`&lt;/pre&gt;

由于使用了x86_64的操作系统，因此能分配2GB以上的内存。32位操作系统中， 每个进程最多只能使用2GB内存。也曾经考虑过启动多个分配2GB以下内存的进程， 但这样一台服务器上的TCP连接数就会成倍增加，管理上也变得复杂， 所以mixi就统一使用了64位操作系统。

另外，虽然服务器的内存为4GB，却仅分配了3GB，是因为内存分配量超过这个值， 就有可能导致内存交换(swap)。连载的[第2次](http://tech.idv2.com/2008/07/11/memcached-002/)中 前坂讲解过了memcached的内存存储“slab allocator”，当时说过，memcached启动时 指定的内存分配量是memcached用于保存数据的量，没有包括“slab allocator”本身占用的内存、 以及为了保存数据而设置的管理空间。因此，memcached进程的实际内存分配量要比 指定的容量要大，这一点应当注意。

mixi保存在memcached中的数据大部分都比较小。这样，进程的大小要比&amp;nbsp;
指定的容量大很多。因此，我们反复改变内存分配量进行验证， 确认了3GB的大小不会引发swap，这就是现在应用的数值。

## memcached使用方法和客户端

现在，mixi的服务将200台左右的memcached服务器作为一个pool使用。 每台服务器的容量为3GB，那么全体就有了将近600GB的巨大的内存数据库。 客户端程序库使用了本连载中多次提到车的Cache::Memcached::Fast， 与服务器进行交互。当然，缓存的分布式算法使用的是&amp;nbsp;[第4次](http://tech.idv2.com/2008/07/24/memcached-004/)介绍过的 Consistent Hashing算法。
</code></pre><ul>
<li><p><a href="http://search.cpan.org/dist/Cache-Memcached-Fast/" target="_blank" rel="external">Cache::Memcached::Fast - search.cpan.org</a></p>
<p>应用层上memcached的使用方法由开发应用程序的工程师自行决定并实现。 但是，为了防止车轮再造、防止Cache::Memcached::Fast上的教训再次发生， 我们提供了Cache::Memcached::Fast的wrap模块并使用。</p>
<h3 id="通过Cache-Memcached-Fast维持连接"><a href="#通过Cache-Memcached-Fast维持连接" class="headerlink" title="通过Cache::Memcached::Fast维持连接"></a>通过Cache::Memcached::Fast维持连接</h3><p>Cache::Memcached的情况下，与memcached的连接（文件句柄）保存在Cache::Memcached包内的类变量中。&nbsp;<br>在mod_perl和FastCGI等环境下，包内的变量不会像CGI那样随时重新启动， 而是在进程中一直保持。其结果就是不会断开与memcached的连接， 减少了TCP连接建立时的开销，同时也能防止短时间内反复进行TCP连接、断开 而导致的TCP端口资源枯竭。</p>
<p>但是，Cache::Memcached::Fast没有这个功能，所以需要在模块之外 将Cache::Memcached::Fast对象保持在类变量中，以保证持久连接。</p>
<pre>`<span>package</span> Gihyo::Memcached;

<span>use</span> strict;
<span>use</span> warnings;
<span>use</span> Cache::Memcached::Fast;

<span>my</span> <span>@server_list</span> = <span>qw</span>/<span>192.168</span>.<span>1.1</span>:<span>11211</span> <span>192.168</span>.<span>1.1</span>:<span>11211</span>/;
<span>my</span> <span>$fast</span>;  <span>## 用于保持对象</span><span><span>sub</span> new {</span><span>my</span> <span>$self</span>  = <span>bless</span> {}, <span>shift</span>;
    <span>if</span> ( !<span>$fast</span> ) {
        <span>$fast</span> = Cache::Memcached::Fast-&gt;new({ <span>servers =&gt;</span> \<span>@server_list</span> });
    }
    <span>$self</span>-&gt;{_fast} = <span>$fast</span>;
    <span>return</span> <span>$self</span>;
}

<span><span>sub</span> get {</span><span>my</span> <span>$self</span> = <span>shift</span>;
   <span>$self</span>-&gt;{_fast}-&gt;get(<span>@_</span>);
}
`</pre>

<p>上面的例子中，Cache::Memcached::Fast对象保存到类变量$fast中。</p>
<h3 id="公共数据的处理和rehash"><a href="#公共数据的处理和rehash" class="headerlink" title="公共数据的处理和rehash"></a>公共数据的处理和rehash</h3><p>诸如mixi的主页上的新闻这样的所有用户共享的缓存数据、设置信息等数据， 会占用许多页，访问次数也非常多。在这种条件下，访问很容易集中到某台memcached服务器上。 访问集中本身并不是问题，但是一旦访问集中的那台服务器发生故障导致memcached无法连接， 就会产生巨大的问题。</p>
<p>连载的<a href="http://tech.idv2.com/2008/07/24/memcached-004/" target="_blank" rel="external">第4次</a>&nbsp;中提到，Cache::Memcached拥有rehash功能，即在无法连接保存数据的服务器的情况下， 会再次计算hash值，连接其他的服务器。</p>
<p>但是，Cache::Memcached::Fast没有这个功能。不过，它能够在连接服务器失败时， 短时间内不再连接该服务器的功能。</p>
<pre>`my <span>$fast</span> = Cache::Memcached::Fast-&gt;<span>new</span>({
    max_failures     =&gt; <span>3</span>,
    failure_timeout  =&gt; <span>1</span>
});
`</pre>

<p>在failure_timeout秒内发生max_failures以上次连接失败，就不再连接该memcached服务器。 我们的设置是1秒钟3次以上。</p>
<p>此外，mixi还为所有用户共享的缓存数据的键名设置命名规则， 符合命名规则的数据会自动保存到多台memcached服务器中， 取得时从中仅选取一台服务器。创建该函数库后，就可以使memcached服务器故障 不再产生其他影响。</p>
<h1 id="memcached应用经验"><a href="#memcached应用经验" class="headerlink" title="memcached应用经验"></a>memcached应用经验</h1><p>到此为止介绍了memcached内部构造和函数库，接下来介绍一些其他的应用经验。</p>
<h2 id="通过daemontools启动"><a href="#通过daemontools启动" class="headerlink" title="通过daemontools启动"></a>通过daemontools启动</h2><p>通常情况下memcached运行得相当稳定，但mixi现在使用的最新版1.2.5 曾经发生过几次memcached进程死掉的情况。架构上保证了即使有几台memcached故障 也不会影响服务，不过对于memcached进程死掉的服务器，只要重新启动memcached， 就可以正常运行，所以采用了监视memcached进程并自动启动的方法。 于是使用了daemontools。</p>
<p>daemontools是qmail的作者DJB开发的UNIX服务管理工具集，&nbsp;<br>其中名为supervise的程序可用于服务启动、停止的服务重启等。</p>
</li>
<li><p><a href="http://cr.yp.to/daemontools.html" target="_blank" rel="external">daemontools</a></p>
<p>这里不介绍daemontools的安装了。mixi使用了以下的run脚本来启动memcached。</p>
<pre>`<span>#!/bin/sh
</span><span>if</span> [ <span>-f</span> /etc/sysconfig/memcached ];<span>then</span>
        . /etc/sysconfig/memcached
<span>fi</span><span>exec</span> <span>2</span>&gt;&amp;<span>1</span><span>exec</span> /usr/bin/memcached -p <span>$PORT</span> -u <span>$USER</span>  -m <span>$CACHESIZE</span> -c <span>$MAXCONN</span> <span>$OPTIONS</span>`</pre>

<h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><p>mixi使用了名为“nagios”的开源监视软件来监视memcached。</p>
</li>
<li><p><a href="http://www.nagios.org/" target="_blank" rel="external">Nagios: Home</a></p>
<p>在nagios中可以简单地开发插件，可以详细地监视memcached的get、add等动作。 不过mixi仅通过stats命令来确认memcached的运行状态。<br><pre>`define command {<br>command_name                   check_memcached<br>command_line                   <span>$USER1</span>$/check_tcp -H <span>$HOSTADDRESS</span>$ -p <span>11211</span> -t <span>5</span> -E <span>-s</span> <span>‘stats\r\nquit\r\n’</span> <span>-e</span> <span>‘uptime’</span> -M crit<br>}</pre></p>
</li>
</ul>
<p>此外，mixi将stats目录的结果通过rrdtool转化成图形，进行性能监视， 并将每天的内存使用量做成报表，通过邮件与开发者共享。</p>
<h2 id="memcached的性能"><a href="#memcached的性能" class="headerlink" title="memcached的性能"></a>memcached的性能</h2><p>连载中已介绍过，memcached的性能十分优秀。我们来看看mixi的实际案例。 这里介绍的图表是服务所使用的访问最为集中的memcached服务器。</p>
<p><img src="http://helloword.1kapp.com/wp-content/uploads/2015/12/wpid-b9b063ef707aab527e9d3324b1588fa6_7b5ee34f-293e-4bb6-8dfc-ec0dcce24c83.png" alt="memcached-0005-02.png"></p>
<p>图2 请求数</p>
<p><img src="http://helloword.1kapp.com/wp-content/uploads/2015/12/wpid-b9b063ef707aab527e9d3324b1588fa6_68e6f6f3-5ba3-49d0-9b2c-c63296c08690.png" alt="memcached-0005-03.png"></p>
<p>图3 流量</p>
<p><img src="http://helloword.1kapp.com/wp-content/uploads/2015/12/wpid-b9b063ef707aab527e9d3324b1588fa6_9ef8e9c2-44ff-4dd4-ab74-2477155d12c5.png" alt="memcached-0005-04.png"></p>
<p>图4 TCP连接数</p>
<p>从上至下依次为请求数、流量和TCP连接数。请求数最大为15000qps， 流量达到400Mbps，这时的连接数已超过了10000个。 该服务器没有特别的硬件，就是开头介绍的普通的memcached服务器。 此时的CPU利用率为：</p>
<p><img src="http://helloword.1kapp.com/wp-content/uploads/2015/12/wpid-b9b063ef707aab527e9d3324b1588fa6_2ea76a59-f8aa-4953-85b7-0fb532f49e44.png" alt="memcached-0005-05.png"></p>
<p>图5 CPU利用率</p>
<p>可见，仍然有idle的部分。因此，memcached的性能非常高， 可以作为Web应用程序开发者放心地保存临时数据或缓存数据的地方。</p>
<h1 id="兼容应用程序"><a href="#兼容应用程序" class="headerlink" title="兼容应用程序"></a>兼容应用程序</h1><p>memcached的实现和协议都十分简单，因此有很多与memcached兼容的实现。&nbsp;<br>一些功能强大的扩展可以将memcached的内存数据写到磁盘上，实现数据的持久性和冗余。 连载<a href="http://tech.idv2.com/2008/07/16/memcached-003/" target="_blank" rel="external">第3次</a>&nbsp;介绍过，以后的memcached的存储层将变成可扩展的（pluggable），逐渐支持这些功能。</p>
<p>这里介绍几个与memcached兼容的应用程序。</p>
<ul>
<li>repcached: 为memcached提供复制(replication)功能的patch。</li>
<li>Flared: 存储到QDBM。同时实现了异步复制和fail over等功能。</li>
<li>memcachedb: 存储到BerkleyDB。还实现了message queue。</li>
<li>Tokyo Tyrant: 将数据存储到Tokyo Cabinet。不仅与memcached协议兼容，还能通过HTTP进行访问。</li>
</ul>
<h2 id="Tokyo-Tyrant案例"><a href="#Tokyo-Tyrant案例" class="headerlink" title="Tokyo Tyrant案例"></a>Tokyo Tyrant案例</h2><p>mixi使用了上述兼容应用程序中的Tokyo Tyrant。Tokyo Tyrant是平林开发的&nbsp;<br>Tokyo Cabinet DBM的网络接口。它有自己的协议，但也拥有memcached兼容协议，&nbsp;<br>也可以通过HTTP进行数据交换。Tokyo Cabinet虽然是一种将数据写到磁盘的实现，但速度相当快。</p>
<p>mixi并没有将Tokyo Tyrant作为缓存服务器，而是将它作为保存键值对组合的DBMS来使用。&nbsp;<br>主要作为存储用户上次访问时间的数据库来使用。它与几乎所有的mixi服务都有关， 每次用户访问页面时都要更新数据，因此负荷相当高。MySQL的处理十分笨重， 单独使用memcached保存数据又有可能会丢失数据，所以引入了Tokyo Tyrant。 但无需重新开发客户端，只需原封不动地使用Cache::Memcached::Fast即可， 这也是优点之一。关于Tokyo Tyrant的详细信息，请参考本公司的开发blog。</p>
<ul>
<li><a href="http://alpha.mixi.co.jp/blog/?p=166" target="_blank" rel="external">mixi Engineers’ Blog - Tokyo Tyrantによる耐高負荷DBの構築</a></li>
<li><a href="http://alpha.mixi.co.jp/blog/?p=185" target="_blank" rel="external">mixi Engineers’ Blog - Tokyo (Cabinet|Tyrant)の新機能</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到本次为止，“memcached全面剖析”系列就结束了。我们介绍了memcached的基础、内部结构、 分散算法和应用等内容。读完后如果您能对memcached产生兴趣，就是我们的荣幸。 关于mixi的系统、应用方面的信息，请参考本公司的<a href="http://alpha.mixi.co.jp/" target="_blank" rel="external">开发blog</a>。 感谢您的阅读。</p>
<div><small>来源：&nbsp;&lt;<a href="http://blog.charlee.li/memcached-005/" target="_blank" rel="external">http://blog.charlee.li/memcached-005/</a><small>&gt;</small></small></div><small><small>&nbsp;</small></small></section><br><br><div><a href="http://www.wiz.cn/i/60efacb7" title="来自为知笔记(Wiz)" target="_blank" rel="external">来自为知笔记(Wiz)</a></div>
      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/编程语言/">编程语言</a>
  </div>

        
        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Kommentare</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2015/12/07/445d8f034e6cdb3945d279103076df2b/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Kategorien</h3>
  <ul class="entry">
  
    <li><a href="/categories/JAVA设计模式/">JAVA设计模式</a><small>5</small></li>
  
    <li><a href="/categories/WEB安全/">WEB安全</a><small>4</small></li>
  
    <li><a href="/categories/应用服务器/">应用服务器</a><small>7</small></li>
  
    <li><a href="/categories/操作系统/">操作系统</a><small>5</small></li>
  
    <li><a href="/categories/数据库知识/">数据库知识</a><small>11</small></li>
  
    <li><a href="/categories/系统架构/">系统架构</a><small>4</small></li>
  
    <li><a href="/categories/编程语言/">编程语言</a><small>7</small></li>
  
    <li><a href="/categories/WEB安全/编程语言/">编程语言</a><small>2</small></li>
  
    <li><a href="/categories/JAVA设计模式/编程语言/">编程语言</a><small>5</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Jdk/">Jdk</a><small>1</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/tags/Memcache/">Memcache</a><small>2</small></li>
  
    <li><a href="/tags/Mongodb/">Mongodb</a><small>3</small></li>
  
    <li><a href="/tags/Nginx/">Nginx</a><small>1</small></li>
  
    <li><a href="/tags/Node-js/">Node.js</a><small>1</small></li>
  
    <li><a href="/tags/Oracle/">Oracle</a><small>2</small></li>
  
    <li><a href="/tags/Weblogic/">Weblogic</a><small>1</small></li>
  
    <li><a href="/tags/Yum/">Yum</a><small>1</small></li>
  
    <li><a href="/tags/数据库知识/">数据库知识</a><small>3</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 John Doe
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
