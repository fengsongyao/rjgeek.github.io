---
title: 【密码学】RSA算法解析-理论基础
id: 813
categories:
  - 密码学
date: 2016-11-13 21:15:54
tags:
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
## 数学基础(Fundamental_Theorem_of_Arithmeti)
### 1.任何合数(Composite Number)都是有若干素数（Prime Number）组成的
6=2\*2\*2  
15=3\*5  
素数是构成元素的基本要素,素数本身是不可再分的，素数是构建，每一个数有且只有一种素数的分解方法，没有两个数会分享同一个素数因子分解  
一个好玩的现象，如果将所有素数进行螺旋排列，所有素数呈现斐波那契螺旋线排列，在计算机下的模拟如下：  
<img src="https://rjgeek.github.io/images/2016/11/rsa_1.png" width = "300" height = "200" alt="图片名称" align=center />
<!--more-->
<img src="https://rjgeek.github.io/images/2016/11/rsa_2.png" width = "300" height = "200" alt="图片名称" align=center />   
自然界中也有很多如贝类的螺旋轮廓线、向日葵轮廓、银河、人的耳朵等这种天然的“黄金螺旋”。至于素数为什么也有这样的特征
我的答案是我也不知道  
<img src="https://rjgeek.github.io/images/2016/11/rsa_3.png" width = "300" height = "200" alt="图片名称" align=center />
<img src="https://rjgeek.github.io/images/2016/11/rsa_4.png" width = "300" height = "200" alt="图片名称" align=center />   
### 2.Diffie-Hellman密钥交换
Diffie-Hellman密钥交换是RSA之前的算法，其中的原理就是单项函数，如下图所示  
在已知下图的模式下，任意跟换X可以获得不同的输出，但是从输出你无法获取X，RSA的算法基石   
<img src="https://rjgeek.github.io/images/2016/11/rsa_6.png?t=1" width = "300" height = "200" alt="图片名称" align=center />
<img src="https://rjgeek.github.io/images/2016/11/rsa_5.png" width = "300" height = "200" alt="图片名称" align=center />  
假设ALICE和BOB进行通信，而EVE是个监听者，首先ALICE根据上左边的选择一个任意的X54经过计算得出结果15发给BOB
<img src="https://rjgeek.github.io/images/2016/11/rsa_8.png?t=1" width = "300" height = "200" alt="图片名称" align=center />
<img src="https://rjgeek.github.io/images/2016/11/rsa_9.png?t=1" width = "300" height = "200" alt="图片名称" align=center />  
BOB同样选择任意一个X24按照上图的公式进行计算得出16，此时54,24分别为ALICE和BOB的私有，15和16则为公开的数据，监听者EVE可以获取15和16  
<img src="https://rjgeek.github.io/images/2016/11/rsa_10.png?t=1" width = "600" height = "200" alt="图片名称" align=center />  

$$(3^{24*54}mod 17) = 1$$   $$(3^{54*24}mod 17) = 1$$ 其中1为将来需要交换的秘钥，两边接收的相同
证明  
$$16^{54}mod 17 = (3^{24}mod17)^{54}mod 17=3^{24*54}mod 17$$
同理  
$$15^{24}mod 17 = (3^{54}mod17)^{24}mod 17=3^{54*24}mod 17$$


### 3.最大公约数
$$a,b\subset Z	$$
$$ a\neq0 $$
$$ b\neq0 $$
Leta;b2Zwitha6=0 andb . The greatest common divisor for a and b, written gcd(a,b), is the largest positive integer that divides both numbers without remainder
翻译汉语：能同时被a和b整除的最大的那个数，成为最大公约数，或者公因子

### 4.互质关系  
如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。  
关于互质关系，不难得到以下结论： 
>  
　　1. 任意两个质数构成互质关系，比如13和61。  
　　2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。  
　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。  
　　4. 1和任意一个自然数是都是互质关系，比如1和99。  
　　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。  
>　　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。  

### 5.欧拉函数  
请思考以下问题：  
***
任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）
***
计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。  
φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。  
*  **第一种情况**  
如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。
*  **第二种情况**  
如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。
*  **第三种情况**  
如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则
$$\phi{(p^k)}=p^k-p^{k-1}$$
比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。
这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、...、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。
上面的式子还可以写成下面的形式：
$$\phi{(p^k)}=p^k-p^{k-1}=p^k(1-\frac{1}{p})$$
可以看出，上面的第二种情况是 k=1 时的特例。
*  **第四种情况**  
如果n可以分解成两个互质的整数之积，  
　　n = p1 × p2  
则  
　　φ(n) = φ(p1p2) = φ(p1)φ(p2)  
即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。
这一条的证明要用到"中国剩余定理"，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。
* ** 第五种情况**  
因为任意一个大于1的正整数，都可以写成一系列质数的积。
$$n=p_1^{k1}p_2^{k2}p_3^{k3}....p_r^{kr}$$
根据第4条的结论，得到
$$\phi{n}=\phi({p_1^{k1}})\phi(p_2^{k2})\phi(p_3^{k3})....\phi(p_r^{kr})$$
再根据第3条的结论，得到
$$\phi{n}=p_1^{k1}p_2^{k2}p_3^{k3}....p_r^{kr}(1-\frac{1}{p_1})(1-\frac{1}{p_2})(1-\frac{1}{p_3})(1-\frac{1}{p_r})$$
也就等于
$$\phi{n}=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})(1-\frac{1}{p_3})(1-\frac{1}{p_r})$$
这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：
$$\phi{1323}=\phi({3^3*7^2})=1323(1-\frac{1}{3})(1-\frac{1}{7})=756$$

### 6.欧拉定理
欧拉函数的用处，在于欧拉定理。"欧拉定理"指的是：
如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：
$$a^{\phi({n})}\equiv 1(mod\quad n)$$
也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。
欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。
欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，
$$7^{\phi({10})}\equiv 1(mod\quad 10)$$
已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。
$$7^{\phi({4k})}\equiv 1(mod\quad 10)$$
因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。
欧拉定理有一个特殊情况。
假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成
$$7^{\phi({p-1})}\equiv 1(mod\quad p)$$
这就是著名的费马小定理。它是欧拉定理的特例。
欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。
### 7.模反元素
还剩下最后一个概念：
如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。
$$ab\equiv 1(mod\quad n)$$
这时，b就叫做a的"模反元素"。
比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...,-18,-7,4,15,26,...}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。
欧拉定理可以用来证明模反元素必然存在。
$$a^{\phi({n})}=a*a^{\phi({n})-1}\equiv 1(mod\quad n)$$
可以看到，a的 φ(n)-1 次方，就是a的模反元素。

### 引用
http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html



